/*
Problem Statement:
Given an integer array `arr`, the task is to find and return the total number of distinct bitwise ORs that can be formed from all possible non-empty subarrays of `arr`. A subarray is defined as a contiguous sequence of elements within the array. The bitwise OR of a subarray containing a single integer is simply that integer.

Approach:
The core idea behind solving this problem efficiently is to leverage the property of the bitwise OR operation: once a bit is set to 1, it remains 1. This implies that for a sequence of numbers `a, b, c, ...`, the OR sum `a | b | c | ...` can only increase or stay the same as more numbers are OR-ed into it. Crucially, for a 32-bit integer, there are at most 32 distinct values that can be generated by successively OR-ing numbers into an initial value. This is because each distinct value must have at least one more bit set than the previous value in the sequence to be different.

We can use a dynamic programming-like approach combined with hash sets to keep track of the unique OR sums.
We iterate through the input array `arr` element by element. At each element `arr[i]`, we determine all possible distinct bitwise OR sums of subarrays that *end* at `arr[i]`.

Let's maintain two sets:
1. `prevOrs`: This set will store all distinct bitwise OR sums of subarrays that ended at the *previous* index (`i-1`).
2. `currentOrs`: This set will store all distinct bitwise OR sums of subarrays that end at the *current* index (`i`).

Additionally, we need a global set:
3. `allOrs`: This set will accumulate *all* distinct bitwise OR sums encountered across *all* subarrays from the beginning of the array up to the current element. This is our final collection of unique OR values.

The algorithm proceeds as follows:

Initialization:
- Initialize `allOrs` as an empty `HashSet<Integer>`. This will store our final result.
- Initialize `prevOrs` as an empty `HashSet<Integer>`. This set will be populated as we iterate.

Iteration:
- For each integer `x` in the input array `arr` (let's say `x` is `arr[i]`):
    a. Create a new `HashSet<Integer>` called `currentOrs`. This set will hold all unique OR sums for subarrays ending at the current `x`.
    b. The simplest subarray ending at `x` is `[x]` itself. So, add `x` to `currentOrs`.
    c. Now, consider extending all subarrays that ended at the previous index (`i-1`). For every `val` in `prevOrs`:
        i. Calculate the bitwise OR of `val` and the current element `x`: `val | x`.
        ii. Add this new OR sum to `currentOrs`.
    d. After processing all `val`s from `prevOrs` and adding `x` itself, `currentOrs` now contains all distinct OR sums for subarrays ending at the current index `i`. Add all elements from `currentOrs` into `allOrs`. This updates our global collection of unique OR sums.
    e. Finally, set `prevOrs = currentOrs`. This prepares `prevOrs` for the next iteration, making the `currentOrs` of the current step the `prevOrs` for the next step.

Result:
- After iterating through all elements of `arr`, the `allOrs` set will contain every distinct bitwise OR sum of all non-empty subarrays.
- Return the size of `allOrs`.

Example Trace (using `arr = [1, 1, 2]`):

Initial:
`allOrs = {}`
`prevOrs = {}`

Iteration 1: `x = 1` (from `arr[0]`)
- `currentOrs = {}`
- Add `1` to `currentOrs`: `currentOrs = {1}`
- `prevOrs` is empty, so no loop for `val | x`.
- Add all from `currentOrs` to `allOrs`: `allOrs = {1}`
- Set `prevOrs = {1}`

Iteration 2: `x = 1` (from `arr[1]`)
- `currentOrs = {}`
- Add `1` to `currentOrs`: `currentOrs = {1}`
- Loop through `prevOrs` (`{1}`):
    - `val = 1`: Calculate `1 | 1 = 1`. Add `1` to `currentOrs`. `currentOrs` remains `{1}`.
- Add all from `currentOrs` to `allOrs`: `allOrs` remains `{1}`.
- Set `prevOrs = {1}`

Iteration 3: `x = 2` (from `arr[2]`)
- `currentOrs = {}`
- Add `2` to `currentOrs`: `currentOrs = {2}`
- Loop through `prevOrs` (`{1}`):
    - `val = 1`: Calculate `1 | 2 = 3`. Add `3` to `currentOrs`. `currentOrs` becomes `{2, 3}`.
- Add all from `currentOrs` to `allOrs`: `allOrs` becomes `{1, 2, 3}`.
- Set `prevOrs = {2, 3}`

End of iterations.
Return `allOrs.size()`, which is `3`.

Complexity Analysis:
- Time Complexity: The outer loop runs `N` times, where `N` is the length of the input array `arr`. Inside the loop, the size of `prevOrs` (and consequently `currentOrs`) is crucial. Due to the nature of bitwise OR operations (only setting bits to 1), the number of distinct values generated by successively OR-ing with a new number can be at most `MaxBits + 1`, where `MaxBits` is the number of bits in an integer (typically 32 for Java `int`). This is because each new distinct value must have at least one more bit set than the previous, and there are only `MaxBits` total bits. Therefore, the inner loop iterates at most `MaxBits` times. `HashSet` operations (add, iteration) have an average time complexity of `O(1)`. Thus, each step of the outer loop takes `O(MaxBits)` time. The total time complexity is `O(N * MaxBits)`. Given `MaxBits` is a small constant (around 32), this effectively becomes `O(N)`.

- Space Complexity:
    - `prevOrs` and `currentOrs` sets each store at most `MaxBits` elements.
    - `allOrs` set, in the worst case, could potentially store up to `N * MaxBits` distinct values if every combination uniquely sets new bits. However, in practice, the number of distinct OR values is much lower, but the upper bound for space is `O(N * MaxBits)`. If `N` is large, and `arr[i]` values are chosen to maximize distinct ORs, the space could approach `N * 32`.

This approach is efficient because it avoids recomputing OR sums for subarrays multiple times and limits the growth of the sets of OR sums ending at each position.

*/

import java.util.HashSet;
import java.util.Set;

class Solution {
    public int bitwiseOrsSubarrays(int[] arr) {
        Set<Integer> allOrs = new HashSet<>(); // Stores all unique bitwise OR sums encountered globally
        Set<Integer> prevOrs = new HashSet<>(); // Stores unique bitwise OR sums of subarrays ending at the previous index

        // Iterate through each element in the input array
        for (int x : arr) {
            Set<Integer> currentOrs = new HashSet<>(); // Stores unique bitwise OR sums of subarrays ending at the current element 'x'
            
            // Case 1: The current element 'x' itself forms a subarray [x]
            currentOrs.add(x);
            
            // Case 2: Extend subarrays that ended at the previous index
            // For each unique OR sum 'val' that ended at the previous index,
            // we can form a new OR sum by including the current element 'x'.
            for (int val : prevOrs) {
                currentOrs.add(val | x);
            }
            
            // Add all newly generated unique OR sums from 'currentOrs' to the global 'allOrs' set
            allOrs.addAll(currentOrs);
            
            // Update 'prevOrs' for the next iteration. The 'currentOrs' of this step
            // will become the 'prevOrs' for the next element.
            prevOrs = currentOrs;
        }
        
        // The total number of distinct bitwise ORs of all non-empty subarrays
        // is simply the size of the 'allOrs' set.
        return allOrs.size();
    }
}